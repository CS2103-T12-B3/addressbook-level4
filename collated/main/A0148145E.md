# A0148145E
###### \java\seedu\taskscheduler\commons\util\DateFormatter.java
``` java

/**
 * Utility methods for Date and time formating.
 */

public class DateFormatter {

    private static DateFormat dateFormatter = new SimpleDateFormat("ddMMyy");
    private static DateFormat timeFormatter = new SimpleDateFormat("HHmm");
    private static DateFormat fullTimeFormatter = new SimpleDateFormat("HHmmss");
    
    private static DateFormat dateDisplayFormatter = new SimpleDateFormat("dd-MMM-yyyy");
    private static DateFormat timeDisplayFormatter = new SimpleDateFormat("hh:mm aa");
    
    public static Date convertStringToDate(String val) throws IllegalValueException {
        try {
            return new PrettyTimeParser().parse(val).get(0);
        } catch (IndexOutOfBoundsException iobe) {
            throw new IllegalValueException(String.format(Messages.MESSAGE_INVALID_DATE_FORMAT,val));
        }
//        try {
//            return dateFormatter.parse(val);
//        } catch (ParseException e) {
//            throw new IllegalValueException(Messages.MESSAGE_INVALID_DATE_FORMAT);
//        }
    }

    public static Date convertStringToTime(String val) throws IllegalValueException {
        try {
            return timeFormatter.parse(val);
        } catch (ParseException e) {
            throw new IllegalValueException(Messages.MESSAGE_INVALID_TIME_FORMAT);
        }
    }

    public static boolean isValidDateString(String val) {
        try {
            dateFormatter.parse(val);
        } catch (ParseException e) {
            return false;
        }
        return true;
    } 
    
    public static boolean isValidTimeString(String val) {
        try {
            timeFormatter.parse(val);
        } catch (ParseException e) {
            return false;
        }
        return true;
    }
//    
//    public static String convertDateToString(Date val) {
//        return dateFormatter.format(val);
//    }
//    
//    public static String convertTimeToString(Date val) {
//        return timeFormatter.format(val);
//    }
    
    public static String convertDateToDisplayString(Date val) {
        return dateDisplayFormatter.format(val);
    }
    
    public static String convertTimeToDisplayString(Date val) {
        return timeDisplayFormatter.format(val);
    }

    public static String convertDateToFullTimeString(Date val) {
        return fullTimeFormatter.format(val);
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\AddCommand.java
``` java
/**
 * Adds a task to the Task Scheduler.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to the scheduler. "
            + "Parameters: TASK_NAME s/START_DATE e/END_DATE at LOCATION  [t/TAG]...\n"
            + "Example: " + COMMAND_WORD
            + " Do CS2103 Pretut\n"
            + "Example: " + COMMAND_WORD
            + " Do CS2103 Pretut by 8am 01-Oct-16\n"
            + "Example: " + COMMAND_WORD
            + " CS2103 Tutorial s/today 8am e/tomorrow 9am at NUS COM1-B103\n";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";

    private final Task toAdd;

    /**
     * Convenience constructor using raw values.
     */
    public AddCommand(Task toAdd) {
        this.toAdd = toAdd;
    }
    
    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addTask(toAdd);
            CommandHistory.setModTask(toAdd);
            CommandHistory.addExecutedCommand(this);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }
    }
    
    @Override
    public CommandResult revert() {
        assert model != null;
        try {
            model.deleteTask(toAdd);
            CommandHistory.setModTask(null);
            CommandHistory.addRevertedCommand(this);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }
        return new CommandResult(String.format(MESSAGE_REVERT_COMMAND, COMMAND_WORD, "\n" + toAdd));
    }

}
```
###### \java\seedu\taskscheduler\logic\commands\AddDeadlineCommand.java
``` java

/**
 * Adds a deadline task to the Task Scheduler.
 */
public class AddDeadlineCommand extends AddCommand {

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddDeadlineCommand(String name, String endDate) 
            throws IllegalValueException {
        super(
            new DeadlineTask(
                new Name(name), 
                new TaskDateTime(endDate))
            );
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\AddEventCommand.java
``` java

/**
* Adds an event task to the Task Scheduler.
*/

public class AddEventCommand extends AddCommand {

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddEventCommand(String name, String startDate, String endDate, String address) 
            throws IllegalValueException {
        
        super(  
            new EventTask(
                new Name(name),
                new TaskDateTime(startDate),
                new TaskDateTime(endDate),
                new Location(address)
                )
            );
        
    }

}
```
###### \java\seedu\taskscheduler\logic\commands\AddFloatingCommand.java
``` java

/**
* Adds a floating task to the Task Scheduler.
*/

public class AddFloatingCommand extends AddCommand {

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddFloatingCommand(String name) throws IllegalValueException {
        super(
            new FloatingTask(
                new Name(name))
            );
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\ClearCommand.java
``` java

/**
 * Clears the Task Scheduler.
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = "clear";
    public static final String MESSAGE_SUCCESS = "Task scheduler has been cleared!";
    private final TaskArray taskArray;
    
    /**
     * Instantiate taskArray which is use to store the cleared tasks for undo
     */
    public ClearCommand() {
        taskArray = new TaskArray();
    }


    @Override
    public CommandResult execute() {
        assert model != null;
        for (ReadOnlyTask task : model.getTaskScheduler().getTaskList()) {
            taskArray.add((Task) task);
        }
        model.resetData(TaskScheduler.getEmptyTaskScheduler());
        CommandHistory.addExecutedCommand(this);
        return new CommandResult(MESSAGE_SUCCESS);
    }


    @Override
    public CommandResult revert() {
        assert model != null;
        try {
            model.addTask(taskArray.getArray());
        } catch (DuplicateTaskException e) {
            assert false : Messages.MESSAGE_TASK_CANNOT_BE_DUPLICATED;
        }
        CommandHistory.addRevertedCommand(this);
        return new CommandResult(String.format(MESSAGE_REVERT_COMMAND, COMMAND_WORD, taskArray.toString()));
        
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\Command.java
``` java
    /**
     * Revert the previous executed command and returns the result message.
     *
     * @return feedback message of the operation result for display
     */
    public abstract CommandResult revert();
```
###### \java\seedu\taskscheduler\logic\commands\DeleteCommand.java
``` java

/**
 * Deletes a task identified using it's last displayed index from the Task Scheduler.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "delete";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task identified by the index number used in the last tasks listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task: %1$s";
    private final int targetIndex;
    private Task taskToDelete;

    public DeleteCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }


    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        taskToDelete = new Task(lastShownList.get(targetIndex - 1));

        try {
        	model.deleteTask(taskToDelete);
        	CommandHistory.addExecutedCommand(this);
        } catch (TaskNotFoundException pnfe) {
            assert false : Messages.MESSAGE_TASK_CANNOT_BE_MISSING;
        }
        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete));
    }


    @Override
    public CommandResult revert() {
        try {
            model.insertTask(targetIndex, taskToDelete);
            CommandHistory.addRevertedCommand(this);
        } catch (TaskNotFoundException e) {
            assert false : Messages.MESSAGE_TASK_CANNOT_BE_MISSING;
        }
        return new CommandResult(String.format(MESSAGE_REVERT_COMMAND, COMMAND_WORD, "\n" + taskToDelete));
    }

}
```
###### \java\seedu\taskscheduler\logic\commands\EditCommand.java
``` java

/**
 * Edits a task in the task scheduler.
 */
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits a task in the scheduler. "
            + "Parameters: INDEX TASK s/START_DATE e/END_DATE at LOCATION \n"
            + "Example: " + COMMAND_WORD
            + " 1 Must Do CS2103 Pretut\n"
            + "Example: " + COMMAND_WORD
            + " 2 new task name s/10-Oct-2016 8am e/10-Oct-2016 9am at NUS\n"
            + "Example: " + COMMAND_WORD
            + " 1 another new task name s/11-Oct-2016 8am e/11-Oct-2016 9am at there\n";

    public static final String MESSAGE_SUCCESS = "Task edited: %1$s";
    
    public final int targetIndex;
    private final Task toCopy;
    private Task toEdit;

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public EditCommand(int targetIndex, Task toCopy)
            throws IllegalValueException {
        
        this.targetIndex = targetIndex;
        this.toCopy = toCopy;
    }

    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        toEdit = (Task)lastShownList.get(targetIndex - 1);

        try {
            model.editTask(toEdit, toCopy);
            CommandHistory.addExecutedCommand(this);
        } catch (DuplicateTaskException dpe) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException pnfe) {
            assert false : Messages.MESSAGE_TASK_CANNOT_BE_MISSING;
        }
        return new CommandResult(String.format(MESSAGE_SUCCESS, toEdit));
    }

    @Override
    public CommandResult revert() {
        try {
            model.editTask(toCopy, toEdit);
            CommandHistory.addRevertedCommand(this);
        } catch (DuplicateTaskException e) {
            assert false : Messages.MESSAGE_TASK_CANNOT_BE_DUPLICATED;
        } catch (TaskNotFoundException e) {
            assert false : Messages.MESSAGE_TASK_CANNOT_BE_MISSING;
        }
        return new CommandResult(String.format(MESSAGE_REVERT_COMMAND, COMMAND_WORD, "\n" + toCopy));
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\EditDeadlineCommand.java
``` java

/**
 * Edits a deadline task in the task scheduler.
 */
public class EditDeadlineCommand extends EditCommand {

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public EditDeadlineCommand(int targetIndex, String name, String endDate)
            throws IllegalValueException {
        super(
            targetIndex,
            new DeadlineTask(
                new Name(name),
                new TaskDateTime(endDate))
        );
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\EditEventCommand.java
``` java

/**
 * Edits an event task in the task scheduler.
 */
public class EditEventCommand extends EditCommand {
    
    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public EditEventCommand(int targetIndex, String name, String startDate, String endDate, String address)
            throws IllegalValueException {
        super(
            targetIndex,
            new EventTask(
                new Name(name),
                new TaskDateTime(startDate),
                new TaskDateTime(endDate),
                new Location(address))
        );
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\EditFloatingCommand.java
``` java

/**
 * Edits a floating task in the task scheduler.
 */
public class EditFloatingCommand extends EditCommand {
    
    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public EditFloatingCommand(int targetIndex, String name)
            throws IllegalValueException {
        super(
            targetIndex,
            new FloatingTask(
                new Name(name))
        );
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\ExitCommand.java
``` java
    @Override
    public CommandResult revert() {
        // This command not available for revert
        assert false : Messages.MESSAGE_PROGRAM_ERROR;
        return null;
    }

}
```
###### \java\seedu\taskscheduler\logic\commands\FindCommand.java
``` java

/**
 * Finds and lists all tasks in task scheduler whose task name contains any of the argument keywords.
 * Keyword matching is not case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all task whose task names contain any of "
            + "the specified keywords and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD...\n"
            + "Example: " + COMMAND_WORD + " CS2103 Tutorial";

    private Set<String> keywords;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(keywords);
        Set<String> temp = CommandHistory.getFilteredKeyWords();
        CommandHistory.setFilteredKeyWords(keywords);
        keywords = temp;
        CommandHistory.addExecutedCommand(this);
        return new CommandResult(getMessageForPersonListShownSummary(model.getFilteredTaskList().size()));
    }

    @Override
    public CommandResult revert() {
        String message;
        if (keywords == null) {
            model.updateFilteredListToShowAll();
            message = ListCommand.MESSAGE_SUCCESS;
        } else {
            model.updateFilteredTaskList(keywords);
            message = getMessageForPersonListShownSummary(model.getFilteredTaskList().size());
        }
        Set<String> temp = CommandHistory.getFilteredKeyWords();
        CommandHistory.setFilteredKeyWords(keywords);
        keywords = temp;
        CommandHistory.addRevertedCommand(this);
        return new CommandResult(message);
    }

}
```
###### \java\seedu\taskscheduler\logic\commands\HelpCommand.java
``` java
    @Override
    public CommandResult revert() {
        // This command not available for revert
        assert false : Messages.MESSAGE_PROGRAM_ERROR;
        return null;
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\IncorrectCommand.java
``` java
    @Override
    public CommandResult revert() {
        // This command not available for revert
        assert false : Messages.MESSAGE_PROGRAM_ERROR;
        return null;
    }

}

```
###### \java\seedu\taskscheduler\logic\commands\ListCommand.java
``` java

/**
 * Lists all tasks in the Task Scheduler to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";

    public static final String MESSAGE_SUCCESS = "Listed all tasks";

    private Set<String> keywords;
    
    public ListCommand() {}

    @Override
    public CommandResult execute() {
        model.updateFilteredListToShowAll();
        keywords = CommandHistory.getFilteredKeyWords();
        CommandHistory.setFilteredKeyWords(null);
        CommandHistory.addExecutedCommand(this);
        return new CommandResult(MESSAGE_SUCCESS);
    }

    @Override
    public CommandResult revert() {
        model.updateFilteredTaskList(keywords);
        CommandHistory.setFilteredKeyWords(keywords);
        CommandHistory.addRevertedCommand(this);
        return new CommandResult(getMessageForPersonListShownSummary(model.getFilteredTaskList().size()));
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\MarkCommand.java
``` java

/**
 * Marks a task in task scheduler as completed.
 */
public class MarkCommand extends Command {
    
    public static final String COMMAND_WORD = "mark";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task identified by the index number used in the last tasks listing as completed.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_MARK_TASK_SUCCESS = "Completed Task: %1$s";
    public static final String MESSAGE_MARK_TASK_FAIL = "This task is already completed.";

    private final int targetIndex;
    private Task taskToMark;
    

    public MarkCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }
    
    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        
        taskToMark = (Task)lastShownList.get(targetIndex - 1);

        try {
        	model.markTask(taskToMark);
        	CommandHistory.addExecutedCommand(this);
        } catch (DuplicateTagException e) {
            return new CommandResult(MESSAGE_MARK_TASK_FAIL);
        } catch (TaskNotFoundException pnfe) {
            assert false : Messages.MESSAGE_TASK_CANNOT_BE_MISSING;
        } 
        return new CommandResult(String.format(MESSAGE_MARK_TASK_SUCCESS, taskToMark));
    }

    @Override
    public CommandResult revert() {
        try {
            model.unMarkTask(taskToMark);
            CommandHistory.addRevertedCommand(this);
        } catch (NullPointerException npe) {
            return new CommandResult(UnmarkCommand.MESSAGE_UNMARK_TASK_FAIL);
        } catch (TaskNotFoundException e) {
            assert false : Messages.MESSAGE_TASK_CANNOT_BE_MISSING;
        }
        return new CommandResult(String.format(MESSAGE_REVERT_COMMAND, COMMAND_WORD, "\n" + taskToMark));       
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\RecurCommand.java
``` java

/**
* Recurs a task in task scheduler.
*/
public class RecurCommand extends Command {

    public static final String COMMAND_WORD = "recur";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Recur a task in the scheduler. "
            + "Parameters: [INDEX] every DATE_TIME_INTERVAL until DATE_TIME\n"
            + "Example: " + COMMAND_WORD
            + " every 1 week until 2 months later\n"
            + "Example: " + COMMAND_WORD
            + " 1 every 3 days until next month";

    public static final String MESSAGE_SUCCESS = "Recur task added: %1$s";
    public static final String MESSAGE_MISSING_TASK = "Invalid index or no previous add command";
    public static final String MESSAGE_FAILURE = "Incorrect recurring specification.\n" + MESSAGE_USAGE;
    public static final String MESSAGE_INVALID_TASK_FOR_RECUR = "Selected task is invalid for recursion," 
            + " please select task with dates";
    
    private final int targetIndex;
    private final String args;
    private final TaskArray taskList;

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public RecurCommand(int targetIndex, String args) {
        this.targetIndex = targetIndex;
        this.args = args;
        this.taskList = new TaskArray();
    }
    
    public RecurCommand(String args) {
        this(0,args);
    }
    
    @Override
    public CommandResult execute() {
        assert model != null;
        ReadOnlyTask task;
        task = getTaskFromIndexOrLastModified();
        if (task == null) {
            return new CommandResult(MESSAGE_MISSING_TASK);
        }
        
        try {
            DateGroup dg = new PrettyTimeParser().parseSyntax(args).get(0);
            addRecurTasks(task, dg, taskList);
            model.addTask(taskList.getArray());
            CommandHistory.addExecutedCommand(this);
            return new CommandResult(String.format(MESSAGE_SUCCESS, taskList.toString()));
            
        } catch (UniqueTaskList.DuplicateTaskException dte) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (IndexOutOfBoundsException ioobe) {
            return new CommandResult(MESSAGE_FAILURE);
        } catch (NullPointerException npe) {
            return new CommandResult(MESSAGE_INVALID_TASK_FOR_RECUR);
        }
    }


    @Override
    public CommandResult revert() {
        assert model != null;
        try {
            model.deleteTask(taskList.getArray());
            CommandHistory.addRevertedCommand(this);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }
        return new CommandResult(String.format(MESSAGE_REVERT_COMMAND, COMMAND_WORD, taskList.toString()));
    }
    
    private void addRecurTasks(ReadOnlyTask task, DateGroup dg, TaskArray taskList) {
        Task toAdd;
        do {
            toAdd = new Task(task);
            toAdd.addDuration(dg.getRecurInterval());
            taskList.add(toAdd);
            task = toAdd;
        } while ((toAdd.getEndDate().getDate().getTime() + dg.getRecurInterval()) 
                < dg.getRecursUntil().getTime());
    }

    private ReadOnlyTask getTaskFromIndexOrLastModified() {
        ReadOnlyTask task;
        if (targetIndex <= 0) {
            task = CommandHistory.getModTask();
        }
        else {
            try {
                UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
                task = lastShownList.get(targetIndex - 1);
            } catch (IndexOutOfBoundsException iobe) {
                return null;
            }
        }
        return task;
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\SelectCommand.java
``` java
    @Override
    public CommandResult revert() {
        // This command not available for revert
        assert false : Messages.MESSAGE_PROGRAM_ERROR;
        return null;
    }

}
```
###### \java\seedu\taskscheduler\logic\parser\AddCommandParser.java
``` java

/**
 * Parses add command user input.
 */
public class AddCommandParser extends CommandParser {

    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    public Command prepareCommand(String args) {
        try {
            args = args.trim();
            
            Matcher matcher = EVENT_DATA_ARGS_FORMAT.matcher(args);
            // Validate arg string format
            if (matcher.matches()) {
                return new AddEventCommand(matcher.group("name"), matcher.group("startDate"),
                    matcher.group("endDate"), matcher.group("address"));
            } else if (containsDelimiters(args)) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                        AddCommand.MESSAGE_USAGE));
            }
    
            matcher = DEADLINE_DATA_ARGS_FORMAT.matcher(args);
            if (matcher.matches()) {
                return new AddDeadlineCommand(matcher.group("name"), matcher.group("endDate"));
            }
            
            matcher = FLOATING_DATA_ARGS_FORMAT.matcher(args);
            if (matcher.matches()) {
                return new AddFloatingCommand(args);
            } else {   
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                        AddCommand.MESSAGE_USAGE));
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
    
    private boolean containsDelimiters(String args) {
        if (args.contains(START_DATE_DELIMITER) || args.contains(END_DATE_DELIMITER)) {
            return true; 
        } else {
            return false;
        }
    }
}
```
###### \java\seedu\taskscheduler\logic\parser\ClearCommandParser.java
``` java

/**
* Parses clear command user input.
*/
public class ClearCommandParser extends CommandParser{

    @Override
    public Command prepareCommand(String args) {
        return new ClearCommand();
    }
}
```
###### \java\seedu\taskscheduler\logic\parser\CommandParser.java
``` java

/**
 * Represents a command parser with hidden internal logic and the ability to be executed.
 */
public abstract class CommandParser {

    protected static final String START_DATE_DELIMITER = "s/";
    protected static final String END_DATE_DELIMITER = "e/";
    
    protected static final Pattern INDEX_COMMAND_FORMAT = Pattern.compile("(?<index>\\d+)(?<arguments>.*)");

    protected static final Pattern TASK_INDEX_ARGS_FORMAT = Pattern.compile("(?<targetIndex>.+)");

    protected static final Pattern KEYWORDS_ARGS_FORMAT =
            Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)"); // one or more keywords separated by whitespace
    
    protected static final Pattern EVENT_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(?<name>[^/]+)"
                    + " "
                    + START_DATE_DELIMITER
                    + "(?<startDate>[^/]*)"
                    + " "
                    + END_DATE_DELIMITER
                    + "(?<endDate>.*)"
                    + "(?>\\s+\\bat\\b)"
                    + "(?<address>.*)"
                    ); 
 
    protected static final Pattern DEADLINE_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(?<name>.+?)"
                    + "(?>(\\s+\\b(by|in|at|on)\\b))"
                    + "(?<endDate>.*)"
                    );
    
    protected static final Pattern FLOATING_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(?<name>[\\p{Alnum} ]+)");

    protected static final Pattern SETPATH_DATA_ARGS_FORMAT =
            Pattern.compile("(?<name>[\\p{Alnum}|/|:|\\s+]+)"); 
    
    /**
     * Returns the specified index in the {@code command} IF a positive unsigned integer is given as the index.
     *   Returns an {@code Optional.empty()} otherwise.
     */
    protected Optional<Integer> parseIndex(String command) {
        final Matcher matcher = TASK_INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if(!StringUtil.isUnsignedInteger(index)){
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }

    public abstract Command prepareCommand(String args);
}
```
###### \java\seedu\taskscheduler\logic\parser\DeleteCommandParser.java
``` java

/**
* Parses delete command user input.
*/
public class DeleteCommandParser extends CommandParser {


    /**
     * Parses arguments in the context of the delete task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    public Command prepareCommand(String args) {

        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        return new DeleteCommand(index.get());
    }
}
```
###### \java\seedu\taskscheduler\logic\parser\EditCommandParser.java
``` java

/**
* Parses edit command user input.
*/
public class EditCommandParser extends CommandParser{
    
    /**
     * Parses arguments in the context of the edit task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    
    public Command prepareCommand(String args) {
        try {
            args = args.trim();
            final Matcher matcher = INDEX_COMMAND_FORMAT.matcher(args);
    
            // Validate arg string format
            if (!matcher.matches()) {
                return new IncorrectCommand(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
            int index = Integer.parseInt(matcher.group("index"));
            assert index >= 0;
            args = matcher.group("arguments").trim();
            Matcher editMatcher = EVENT_DATA_ARGS_FORMAT.matcher(args);
            
            if (editMatcher.matches()) {
                return new EditEventCommand(index, editMatcher.group("name"), editMatcher.group("startDate"),
                        editMatcher.group("endDate"), editMatcher.group("address"));
            }
            editMatcher = DEADLINE_DATA_ARGS_FORMAT.matcher(args);
            
            if (editMatcher.matches()) {
                return new EditDeadlineCommand(index, editMatcher.group("name"),
                        editMatcher.group("endDate")); 
            }
            
            editMatcher = FLOATING_DATA_ARGS_FORMAT.matcher(args);
            if (editMatcher.matches()) {
                return new EditFloatingCommand(index, args);
            } else {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));      
            }

        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
}
```
###### \java\seedu\taskscheduler\logic\parser\ExitCommandParser.java
``` java

/**
* Parses exit command user input.
*/
public class ExitCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        return new ExitCommand();
    }
    

}
```
###### \java\seedu\taskscheduler\logic\parser\FindCommandParser.java
``` java

/**
* Parses find command user input.
*/
public class FindCommandParser extends CommandParser {

    /**
     * Parses arguments in the context of the find task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    public Command prepareCommand(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }

}
```
###### \java\seedu\taskscheduler\logic\parser\HelpCommandParser.java
``` java

/**
* Parses help command user input.
*/
public class HelpCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        return new HelpCommand();
    }

    
}
```
###### \java\seedu\taskscheduler\logic\parser\ListCommandParser.java
``` java

/**
* Parses list command user input.
*/
public class ListCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        return new ListCommand();
    }

    
}
```
###### \java\seedu\taskscheduler\logic\parser\MarkCommandParser.java
``` java

/**
* Parses mark command user input.
*/
public class MarkCommandParser extends CommandParser {

    /**
     * Parses arguments in the context of the mark task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    public Command prepareCommand(String args) {

        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkCommand.MESSAGE_USAGE));
        }

        return new MarkCommand(index.get());
    }

}
```
###### \java\seedu\taskscheduler\logic\parser\Parser.java
``` java
    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");

        try {
            String className = "seedu.taskscheduler.logic.parser."
                    +   commandWord.substring(0,1).toUpperCase() 
                    +   commandWord.substring(1)
                    +   "CommandParser";
                    
            CommandParser commandParser = (CommandParser)Class.forName(className).newInstance();
            return commandParser.prepareCommand(arguments);
            
        } catch (Exception e) {
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        } 

    }
```
###### \java\seedu\taskscheduler\logic\parser\RecurCommandParser.java
``` java

/**
* Parses recur command user input.
*/
public class RecurCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        
        args = args.trim();
        if (args.isEmpty()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                    RecurCommand.MESSAGE_USAGE));
        }
        Matcher matcher = INDEX_COMMAND_FORMAT.matcher(args);
        if(matcher.matches()){
            return new RecurCommand(Integer.parseInt(matcher.group("index")),
                    matcher.group("arguments"));
        } else {
            return new RecurCommand(args);
        }
    }
}
```
###### \java\seedu\taskscheduler\logic\parser\SelectCommandParser.java
``` java

/**
* Parses select command user input.
*/
public class SelectCommandParser extends CommandParser {

    /**
     * Parses arguments in the context of the select task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    public Command prepareCommand(String args) {
        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
        }

        return new SelectCommand(index.get());
    }
}
```
###### \java\seedu\taskscheduler\model\Model.java
``` java
    /** Deletes the given task. */
    void deleteTask(ReadOnlyTask... targets) throws UniqueTaskList.TaskNotFoundException;

```
###### \java\seedu\taskscheduler\model\Model.java
``` java
    /** Marks the given task. */
    void markTask(ReadOnlyTask target) throws UniqueTaskList.TaskNotFoundException, DuplicateTagException;

```
###### \java\seedu\taskscheduler\model\Model.java
``` java
    /** Unmarks the given task. */
    void unMarkTask(ReadOnlyTask target) throws UniqueTaskList.TaskNotFoundException;

```
###### \java\seedu\taskscheduler\model\Model.java
``` java
    /** Adds the given task */
    void addTask(Task... tasks) throws UniqueTaskList.DuplicateTaskException;
    
```
###### \java\seedu\taskscheduler\model\Model.java
``` java
    /** Edits the given task. 
     * @throws DuplicateTaskException */
    void editTask(ReadOnlyTask target, Task task) throws TaskNotFoundException, DuplicateTaskException;
```
###### \java\seedu\taskscheduler\model\ModelManager.java
``` java
    @Override
    public synchronized void deleteTask(ReadOnlyTask... target) throws TaskNotFoundException {
        for (ReadOnlyTask task : target) {
            taskScheduler.removeTask(task);
        }
        indicateTaskSchedulerChanged();
    }

    @Override
    public synchronized void addTask(Task... tasks) throws UniqueTaskList.DuplicateTaskException {
        for (Task task : tasks) {
            taskScheduler.addTask(task);
        }
        updateFilteredListToShowAll();
        indicateTaskSchedulerChanged();
    }

    @Override
    public void editTask(ReadOnlyTask oldTask, Task newTask) 
            throws TaskNotFoundException, UniqueTaskList.DuplicateTaskException {
        taskScheduler.editTask(oldTask, newTask);
        updateFilteredListToShowAll();
        indicateTaskSchedulerChanged();
        
    }   

    @Override
    public void markTask(ReadOnlyTask task) 
            throws TaskNotFoundException, DuplicateTagException {
        taskScheduler.markTask(task);
        updateFilteredListToShowAll();
        indicateTaskSchedulerChanged();
    }

    @Override
    public void unMarkTask(ReadOnlyTask task) 
            throws TaskNotFoundException, NullPointerException {
        taskScheduler.unMarkTask(task);
        updateFilteredListToShowAll();
        indicateTaskSchedulerChanged();
    }
    
```
###### \java\seedu\taskscheduler\model\task\DeadlineTask.java
``` java
/**
 * Represents a Deadline Task in the task scheduler.
 */
public class DeadlineTask extends Task {

    public DeadlineTask(Name name, TaskDateTime endDateTime) throws IllegalValueException {
        super(
            name, 
            new TaskDateTime(), 
            endDateTime, 
            new Location(), 
            new UniqueTagList(new Tag("Deadline")));
    }

    public DeadlineTask(ReadOnlyTask source) {
        super(source);
    }

    public Task copy() {
        return new DeadlineTask(this);
    }
}
```
###### \java\seedu\taskscheduler\model\task\EventTask.java
``` java
/**
 * Represents an Event Task in the task scheduler.
 */
public class EventTask extends Task{

    public EventTask(Name name, TaskDateTime startDateTime, TaskDateTime endDateTime, Location address) throws IllegalValueException {
        super(name, startDateTime, endDateTime, address, new UniqueTagList(new Tag("Event")));
    }
    
    public EventTask(ReadOnlyTask source) {
        super(source);
    }

    @Override
    public Task copy() {
        return new EventTask(this);
    }
}
```
###### \java\seedu\taskscheduler\model\task\FloatingTask.java
``` java
/**
 * Represents a Floating Task in the task scheduler.
 */
public class FloatingTask extends Task {

    public FloatingTask(Name name) {
        super(name, new TaskDateTime(), new TaskDateTime(), new Location(), new UniqueTagList());
    }

    public FloatingTask(ReadOnlyTask source) {
        super(source);
    }

    @Override
    public Task copy() {
        return new FloatingTask(this);
    }
}
```
###### \java\seedu\taskscheduler\model\task\Task.java
``` java
/**
 * Represents a Task in the task scheduler.
 * Guarantees: details are present and not null, field values are validated.
 */
public class Task implements ReadOnlyTask {

    private Name name;
    private TaskDateTime startDateTime;
    private TaskDateTime endDateTime;
    private Location address;
    
    private UniqueTagList tags;

    /**
     * Every field must be present and not null.
     */
    public Task(Name name, TaskDateTime startDateTime, TaskDateTime endDateTime, Location address, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(name, startDateTime, endDateTime, address, tags);
        this.name = name;
        this.startDateTime = new TaskDateTime(startDateTime);
        this.endDateTime = new TaskDateTime(endDateTime);
        this.address = address;
        this.tags = new UniqueTagList(tags);
    }

    /**
     * Copy constructor.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getStartDate(), source.getEndDate(), source.getLocation(), source.getTags());
    }

    @Override
    public Name getName() {
        return name;
    }

    @Override
    public TaskDateTime getStartDate() {
        return startDateTime;
    }

    @Override
    public TaskDateTime getEndDate() {
        return endDateTime;
    }

    @Override
    public Location getLocation() {
        return address;
    }
    
    public void setName(Name name) {
        this.name = name;
    }
    
    public void setStartDate(TaskDateTime startDate) {
        this.startDateTime = startDate;
    }
    
    public void setEndDate(TaskDateTime endDate) {
        this.endDateTime = endDate;
    }

    public void setLocation(Location address) {
        this.address = address;
    }
    
    public void addDuration(long duration) {
        if (startDateTime.getDate() != null)
            this.startDateTime.setDate(startDateTime.getDate().getTime() + duration + 1);
        if (endDateTime.getDate() != null)
            this.endDateTime.setDate(endDateTime.getDate().getTime() + duration + 1);
    }
    
    /**
     * Add completed tag to indicate task done.
     */
    public void markComplete() throws DuplicateTagException {
        try {
            this.tags.add(new Tag("Completed"));
        } catch (DuplicateTagException dte) { 
            throw dte;
        } catch (IllegalValueException ive) {
            assert false : "The tag cannot be illegal value";
        } 
    }

    /**
     * Add completed tag to indicate task done.
     */
    public void unMarkComplete() throws NullPointerException {
        try {
            this.tags.remove(new Tag("Completed"));
        }
        catch (NullPointerException npe) { 
            throw npe;
        } catch (IllegalValueException ive) {
            assert false : "The tag cannot be illegal value";
        }
    }
    
    public void copyField(Task task) {
        setName(task.getName());
        setStartDate(task.getStartDate());
        setEndDate(task.getEndDate());
        setLocation(task.getLocation());
        setTags(task.getTags());
     }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }

    /**
     * Replaces this task's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, startDateTime, endDateTime, address);
    }

    @Override
    public String toString() {
        return getAsText();
    }

    @Override
    public Task copy() {
        return new Task(this);
    }

}
```
###### \java\seedu\taskscheduler\model\task\TaskArray.java
``` java

/**
 * Represents the Task array model.
 */

public class TaskArray {

    private final ArrayList<Task> taskList;
    
    public TaskArray() {
        taskList = new ArrayList<Task>();
    }
    
    public void add(Task task) {
        taskList.add(task);
    }

    public Task[] getArray() {
        return taskList.toArray(new Task[taskList.size()]);
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (Task task : taskList) {
            sb.append("\n");
            sb.append(task.toString());
        }
        return sb.toString();
    }
    
}
```
###### \java\seedu\taskscheduler\model\task\TaskDateTime.java
``` java

/**
* Represents the Task date and time model.
*/
public class TaskDateTime {

    private Date date;
    private boolean enShowTime = false;
    
    public TaskDateTime() {
        date = null;
    }
    
    public TaskDateTime(TaskDateTime source) {
        this.date = source.getDate();
        this.enShowTime = source.enShowTime;
    }
    
    public TaskDateTime(String args) throws IllegalValueException {
        if (args == null || args.trim().isEmpty())
            return;
        
        date = DateFormatter.convertStringToDate(args);
        checkIfTimeIsSpecified(new Date());
    }

    public void setDate(long l) { 
        Date newDate = new Date(l);
        checkIfTimeIsSpecified(newDate);
        this.date = newDate; 
    }

    private void checkIfTimeIsSpecified(Date other) {
        if (!DateFormatter.convertDateToFullTimeString(date)
                .equals(DateFormatter.convertDateToFullTimeString(other))) {
            enShowTime = true;
        }
    }
    
    public Date getDate() { 
        return date;
    }
    
    public String getDisplayDateString() {
        if (date == null)
            return "";
        else 
            return DateFormatter.convertDateToDisplayString(date);
    }
    
    public String getDisplayTimeString() {
        if (enShowTime)
            return " " + DateFormatter.convertTimeToDisplayString(date);
        else
            return "";
    }
    
    public boolean getEnShowTime() {
        return enShowTime;
    }
    
    public String getDisplayString() {
        return getDisplayDateString() + getDisplayTimeString();
    }
    
    public String toString() {
        return getDisplayString();
    }
    
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskDateTime // instanceof handles nulls
                && isSameStateAs((TaskDateTime) other));
    }
    
    public boolean isSameStateAs(TaskDateTime other) {
        return getDisplayString().equals(other.getDisplayString());
    }
}
```
###### \java\seedu\taskscheduler\model\task\UniqueTaskList.java
``` java
    /**
     * Edits a task to the list.
     *
     * @throws DuplicateTaskException if the task to add is a duplicate of an existing task in the list.
     */
    public void edit(ReadOnlyTask toEdit, Task toCopy) throws DuplicateTaskException, TaskNotFoundException{
        assert toEdit != null;
        if (contains(toCopy)) {
            throw new DuplicateTaskException();
        }
        int index = internalList.indexOf(toEdit);
        if (index < 0) {
            throw new TaskNotFoundException();
        }
        internalList.set(index, toCopy);
    }

```
###### \java\seedu\taskscheduler\model\task\UniqueTaskList.java
``` java
    /**
     * Marks a task to the list as completed.
     *
     * @throws TaskNotFoundException
     * @throws DuplicateTagException if the task is already complete.
     */
    public void mark(ReadOnlyTask toMark) throws TaskNotFoundException, DuplicateTagException{
        assert toMark != null;
        int index = internalList.indexOf(toMark);
        if (index < 0) {
            throw new TaskNotFoundException();
        }
        Task newTask = new Task(toMark);
        newTask.markComplete();
        internalList.set(index, newTask);
    }
    

```
###### \java\seedu\taskscheduler\model\task\UniqueTaskList.java
``` java
    /**
     * Unmarks a task to the list as completed.
     *
     * @throws TaskNotFoundException
     * @throws DuplicateTagException if the task is already complete.
     */
    public void unMark(ReadOnlyTask toMark) throws TaskNotFoundException, NullPointerException {
        assert toMark != null;
        int index = internalList.indexOf(toMark);
        if (index < 0) {
            throw new TaskNotFoundException();
        }
        Task newTask = new Task(toMark);
        newTask.unMarkComplete();
        internalList.set(index, newTask);
    }
    
```
###### \java\seedu\taskscheduler\model\TaskScheduler.java
``` java
    /**
     * Edits a task in the task scheduler
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void editTask(ReadOnlyTask oldTask, Task newTask) 
            throws UniqueTaskList.DuplicateTaskException, UniqueTaskList.TaskNotFoundException {
        tasks.edit(oldTask, newTask);        
        syncTagsWithMasterList(newTask);
    }

```
###### \java\seedu\taskscheduler\model\TaskScheduler.java
``` java
    /**
     * Marks a task in the task scheduler as completed
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     * @throws DuplicateTagException 
     */
    public void markTask(ReadOnlyTask task) 
            throws UniqueTaskList.TaskNotFoundException, DuplicateTagException {
        syncTagsWithMasterList((Task)task);
        tasks.mark(task);
    }

```
###### \java\seedu\taskscheduler\model\TaskScheduler.java
``` java
    /**
     * Unmarks a task in the task scheduler as completed
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     * @throws DuplicateTagException 
     */
    public void unMarkTask(ReadOnlyTask task) 
            throws UniqueTaskList.TaskNotFoundException, NullPointerException {
        syncTagsWithMasterList((Task)task);
        tasks.unMark(task);
    }
    
```
###### \java\seedu\taskscheduler\ui\TaskCard.java
``` java
    public void hideFieldsAccordingToType(ReadOnlyTask task) {
        
        if (task.tagsString().contains("Event")) {
        } else if (task.tagsString().contains("Deadline")) {
            phone.setVisible(false);
            address.setVisible(false);
        } else {
            phone.setVisible(false);
            address.setVisible(false);
            email.setVisible(false);
        }
    }

```
###### \java\seedu\taskscheduler\ui\TaskCard.java
``` java
    public void indicatingColourByCondition(ReadOnlyTask task) {
        
        if (task.tagsString().contains("Completed")) {
            // if task completed
            cardPane.setStyle(COMPLETED_INDICATION);
        } else if (task.getEndDate().getDate() != null && task.getEndDate().getDate().before(new Date())) {
            // if task overdue
            cardPane.setStyle(OVERDUE_INDICATION);
        }
        
    }
}
```
