# A0148145E
###### \java\seedu\taskscheduler\commons\util\CollectionUtil.java
``` java
    /**
     * Returns true if all of the given items are null.
     */
    public static boolean isAllNull(Object... items) {
        for (Object item : items) {
            if (item != null) {
                return false;
            }
        }
        return true;
    }
```
###### \java\seedu\taskscheduler\commons\util\DateFormatter.java
``` java

/**
 * Utility methods for Date and time formating.
 */

public class DateFormatter {

    private static DateFormat fullTimeFormatter = new SimpleDateFormat("HHmmss");
    
    private static DateFormat dateDisplayFormatter = new SimpleDateFormat("dd-MMM-yyyy, EEE");
    private static DateFormat timeDisplayFormatter = new SimpleDateFormat("hh:mm aa");
    
    public static Date convertStringToDate(String val) throws IllegalValueException {
        try {
            return new PrettyTimeParser().parse(val).get(0);
        } catch (IndexOutOfBoundsException iobe) {
            throw new IllegalValueException(String.format(Messages.MESSAGE_INVALID_DATE_FORMAT,val.trim()));
        }
    }
    
    public static String convertDateToDisplayString(Date val) {
        return dateDisplayFormatter.format(val);
    }
    
    public static String convertTimeToDisplayString(Date val) {
        return timeDisplayFormatter.format(val);
    }

    public static String convertDateToFullTimeString(Date val) {
        return fullTimeFormatter.format(val);
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\AddCommand.java
``` java
/**
 * Adds a task to the Task Scheduler.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to the scheduler. "
            + "Parameters: TASK_NAME from START_DATE to END_DATE at LOCATION  [t/TAG]...\n"
            + "Example: " + COMMAND_WORD
            + " Do CS2103 Pretut\n"
            + "Example: " + COMMAND_WORD
            + " Do CS2103 Pretut by 8am 01-Oct-16\n"
            + "Example: " + COMMAND_WORD
            + " CS2103 Tutorial from today 8am to tomorrow 9am at NUS COM1-B103\n";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";

    private final Task toAdd;

    /**
     * Convenience constructor using raw values.
     */
    public AddCommand(Task toAdd) {
        this.toAdd = toAdd;
    }
    
    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addTask(toAdd);
            CommandHistory.setModTask(toAdd);
            CommandHistory.addExecutedCommand(this);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }
    }
    
    @Override
    public CommandResult revert() {
        assert model != null;
        try {
            model.deleteTask(toAdd);
            CommandHistory.setModTask(null);
            CommandHistory.addRevertedCommand(this);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }
        return new CommandResult(String.format(MESSAGE_REVERT_COMMAND, COMMAND_WORD, "\n" + toAdd));
    }

}
```
###### \java\seedu\taskscheduler\logic\commands\ClearCommand.java
``` java

/**
 * Clears the Task Scheduler.
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = "clear";
    public static final String MESSAGE_SUCCESS = "Task scheduler has been cleared!";
    private final TaskArray taskArray;
    
    /**
     * Instantiate taskArray which is use to store the cleared tasks for undo
     */
    public ClearCommand() {
        taskArray = new TaskArray();
    }


    @Override
    public CommandResult execute() {
        assert model != null;
        for (ReadOnlyTask task : model.getTaskScheduler().getTaskList()) {
            taskArray.add((Task) task);
        }
        model.resetData(TaskScheduler.getEmptyTaskScheduler());
        CommandHistory.addExecutedCommand(this);
        return new CommandResult(MESSAGE_SUCCESS);
    }


    @Override
    public CommandResult revert() {
        assert model != null;
        try {
            model.addTask(taskArray.getArray());
        } catch (DuplicateTaskException e) {
            assert false : Messages.MESSAGE_TASK_CANNOT_BE_DUPLICATED;
        }
        CommandHistory.addRevertedCommand(this);
        return new CommandResult(String.format(MESSAGE_REVERT_COMMAND, COMMAND_WORD, taskArray.toString()));
        
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\Command.java
``` java
    /**
     * Revert the previous executed command and returns the result message.
     *
     * @return feedback message of the operation result for display
     */
    public abstract CommandResult revert();
```
###### \java\seedu\taskscheduler\logic\commands\DeleteCommand.java
``` java

/**
 * Deletes a task identified using it's last displayed index from the Task Scheduler.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "delete";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task identified by the index number used in the last tasks listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task: %1$s";
    private final int targetIndex;
    private Task taskToDelete;

    public DeleteCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }


    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        taskToDelete = (Task) lastShownList.get(targetIndex - 1);

        try {
        	model.deleteTask(taskToDelete);
            CommandHistory.setModTask(null);
        	CommandHistory.addExecutedCommand(this);
        } catch (TaskNotFoundException pnfe) {
            assert false : Messages.MESSAGE_TASK_CANNOT_BE_MISSING;
        }
        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete));
    }


    @Override
    public CommandResult revert() {
        try {
            model.addTask(taskToDelete);
//            model.insertTask(targetIndex, taskToDelete);
            CommandHistory.setModTask(taskToDelete);
            CommandHistory.addRevertedCommand(this);
        } catch (DuplicateTaskException e) {
            assert false : Messages.MESSAGE_TASK_CANNOT_BE_DUPLICATED;
        }
        return new CommandResult(String.format(MESSAGE_REVERT_COMMAND, COMMAND_WORD, "\n" + taskToDelete));
    }

}
```
###### \java\seedu\taskscheduler\logic\commands\EditCommand.java
``` java
/**
 * Adds a task to the Task Scheduler.
 */
public class EditCommand extends Command {


    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits a task in the scheduler. "
            + "Parameters: INDEX TASK from START_DATE to END_DATE at LOCATION \n"
            + "Example: " + COMMAND_WORD
            + " 1 Must Do CS2103 Pretut\n"
            + "Example: " + COMMAND_WORD
            + " 2 at NUS COM1-B103\n"
            + "Example: " + COMMAND_WORD
            + " 1 from 11-Oct-2016 8am to 11-Oct-2016 9am\n";

    public static final String MESSAGE_SUCCESS = "Task editted: %1$s";

    private final String args;
    private final int targetIndex;
    private Name name;
    private TaskDateTime startDate;
    private TaskDateTime endDate;
    private Location address;
    
    private Task oldTask;
    private Task newTask;
    /**
     * Convenience constructor using raw values.
     */
    public EditCommand(int targetIndex, String args) {
        this.targetIndex = targetIndex;
        this.args = args;
    }
    
    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            oldTask = (Task)getTaskFromIndexOrLastModified(targetIndex);
            extractParamsFromArgs();
            if (CollectionUtil.isAllNull(name, startDate, endDate, address)) {
                return new CommandResult(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
            } 
            newTask = assignParamsToTask(oldTask);
            model.replaceTask(oldTask, newTask);
            CommandHistory.addExecutedCommand(this);
            CommandHistory.setModTask(newTask);
            
        } catch (DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException | IllegalValueException ex) {
            return new CommandResult(ex.getMessage());
        }
        return new CommandResult(String.format(MESSAGE_SUCCESS, oldTask));
    }

    @Override
    public CommandResult revert() {
        try {
            model.replaceTask(newTask, oldTask);
            CommandHistory.addRevertedCommand(this);
            CommandHistory.setModTask(oldTask);
        } catch (DuplicateTaskException e) {
            assert false : Messages.MESSAGE_TASK_CANNOT_BE_DUPLICATED;
        } catch (TaskNotFoundException e) {
            assert false : Messages.MESSAGE_TASK_CANNOT_BE_MISSING;
        }
        return new CommandResult(String.format(MESSAGE_REVERT_COMMAND, COMMAND_WORD, "\n" + newTask));
    }

    private void extractParamsFromArgs() throws IllegalValueException {
        String args = this.args;
        args = extractAddressFromArgs(args);
        args = extractDatetimesFromArgs(args);
        extractNameFromArgs(args);
    }
    
    private String extractAddressFromArgs(String args) throws IllegalValueException {
        if (args.contains("at ")) {
            int index = args.lastIndexOf("at ");
            address = new Location(args.substring(index + 3).trim());
            return args.substring(0, index);
        }
        return args;
    }
    
    private String extractDatetimesFromArgs(String args) throws IllegalValueException {
        if (args.contains("from ") && args.contains("to ")) {
            int indexTo = args.lastIndexOf("to ");
            int indexFrom = args.lastIndexOf("from ");
            endDate = new TaskDateTime(args.substring(indexTo));
            startDate = new TaskDateTime(args.substring(indexFrom, indexTo));
            return args.substring(0, indexFrom);
        } else {
            return extractEndDateTimeFromArgs(args);
        }
    }
    
    private String extractEndDateTimeFromArgs(String args) throws IllegalValueException {
        if (args.contains("by ")) {
            int index = args.lastIndexOf("by ");
            endDate = new TaskDateTime(args.substring(index));
            return args.substring(0, index);
        }
        return args;
    }
    private void extractNameFromArgs(String args) throws IllegalValueException {
        if (!args.trim().isEmpty()) {
            name = new Name(args.trim());
        }
    }
    
    private Task assignParamsToTask(Task task) {
        Task newTask = new Task(task);
        if (task.getType() != TaskType.EVENT && (address != null || startDate != null))
            newTask.setType(TaskType.EVENT);
        else if (endDate != null && task.getType() == TaskType.FLOATING) {
            newTask.setType(TaskType.DEADLINE);
        }
        if (startDate != null) {
            newTask.setStartDate(startDate);
        }
        if (endDate != null) {
            newTask.setEndDate(endDate);
        }
        if (address != null) {
            newTask.setLocation(address);
        }
        if (name != null) {
            newTask.setName(name);
        }
        return newTask;
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\ExitCommand.java
``` java
    @Override
    public CommandResult revert() {
        // This command not available for revert
        assert false : Messages.MESSAGE_PROGRAM_ERROR;
        return null;
    }

}
```
###### \java\seedu\taskscheduler\logic\commands\FindCommand.java
``` java

/**
 * Finds and lists all tasks in task scheduler whose task name contains any of the argument keywords.
 * Keyword matching is not case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all task whose task names contain any of "
            + "the specified keywords and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD...\n"
            + "Example: " + COMMAND_WORD + " CS2103 Tutorial";

    private Set<String> keywords;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(keywords);
        Set<String> temp = CommandHistory.getFilteredKeyWords();
        CommandHistory.setFilteredKeyWords(keywords);
        keywords = temp;
        CommandHistory.addExecutedCommand(this);
        return new CommandResult(getMessageForPersonListShownSummary(model.getFilteredTaskList().size()));
    }

    @Override
    public CommandResult revert() {
        String message;
        if (keywords == null) {
            model.updateFilteredListToShowAll();
            message = ListCommand.MESSAGE_SUCCESS;
        } else {
            model.updateFilteredTaskList(keywords);
            message = getMessageForPersonListShownSummary(model.getFilteredTaskList().size());
        }
        Set<String> temp = CommandHistory.getFilteredKeyWords();
        CommandHistory.setFilteredKeyWords(keywords);
        keywords = temp;
        CommandHistory.addRevertedCommand(this);
        return new CommandResult(message);
    }

}
```
###### \java\seedu\taskscheduler\logic\commands\HelpCommand.java
``` java
    @Override
    public CommandResult revert() {
        // This command not available for revert
        assert false : Messages.MESSAGE_PROGRAM_ERROR;
        return null;
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\IncorrectCommand.java
``` java
    @Override
    public CommandResult revert() {
        // This command not available for revert
        assert false : Messages.MESSAGE_PROGRAM_ERROR;
        return null;
    }

}

```
###### \java\seedu\taskscheduler\logic\commands\ListCommand.java
``` java

/**
 * Lists all tasks in the Task Scheduler to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";

    public static final String MESSAGE_SUCCESS = "Listed all tasks";

    private Set<String> keywords;
    
    @Override
    public CommandResult execute() {
        model.updateFilteredListToShowAll();
        keywords = CommandHistory.getFilteredKeyWords();
        CommandHistory.setFilteredKeyWords(null);
        CommandHistory.addExecutedCommand(this);
        return new CommandResult(MESSAGE_SUCCESS);
    }

    @Override
    public CommandResult revert() {
        model.updateFilteredTaskList(keywords);
        CommandHistory.setFilteredKeyWords(keywords);
        CommandHistory.addRevertedCommand(this);
        return new CommandResult(getMessageForPersonListShownSummary(model.getFilteredTaskList().size()));
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\MarkCommand.java
``` java

/**
 * Marks a task in task scheduler as completed.
 */
public class MarkCommand extends Command {
    
    public static final String COMMAND_WORD = "mark";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task identified by the index number used in the last tasks listing as completed.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_MARK_TASK_SUCCESS = "Completed Task: %1$s";
    public static final String MESSAGE_MARK_TASK_FAIL = "This task is already completed.";

    private final int targetIndex;
    private Task taskToMark;
    

    public MarkCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }
    
    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        
        taskToMark = (Task)lastShownList.get(targetIndex - 1);

        try {
        	model.markTask(taskToMark);
        	CommandHistory.addExecutedCommand(this);
        } catch (IllegalValueException e) {
            return new CommandResult(MESSAGE_MARK_TASK_FAIL);
        } catch (TaskNotFoundException pnfe) {
            assert false : Messages.MESSAGE_TASK_CANNOT_BE_MISSING;
        } 
        return new CommandResult(String.format(MESSAGE_MARK_TASK_SUCCESS, taskToMark));
    }

    @Override
    public CommandResult revert() {
        try {
            model.unMarkTask(taskToMark);
            CommandHistory.addRevertedCommand(this);
        } catch (IllegalValueException npe) {
            return new CommandResult(UnmarkCommand.MESSAGE_UNMARK_TASK_FAIL);
        } catch (TaskNotFoundException e) {
            assert false : Messages.MESSAGE_TASK_CANNOT_BE_MISSING;
        }
        return new CommandResult(String.format(MESSAGE_REVERT_COMMAND, COMMAND_WORD, "\n" + taskToMark));       
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\RecurCommand.java
``` java

/**
* Recurs a task in task scheduler.
*/
public class RecurCommand extends Command {

    public static final String COMMAND_WORD = "recur";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Recur a task in the scheduler. "
            + "Parameters: [INDEX] every DATE_TIME_INTERVAL until DATE_TIME\n"
            + "Example: " + COMMAND_WORD
            + " every 1 week until 2 months later\n"
            + "Example: " + COMMAND_WORD
            + " 1 every 3 days until next month";

    public static final String MESSAGE_SUCCESS = "Recur task added: %1$s";
    public static final String MESSAGE_MISSING_TASK = "Invalid index or no previous add command";
    public static final String MESSAGE_FAILURE = "Incorrect recurring specification.\n" + MESSAGE_USAGE;
    public static final String MESSAGE_INVALID_TASK_FOR_RECUR = "Selected task is invalid for recursion," 
            + " please select task with dates";
    
    private final int targetIndex;
    private final String args;
    private final TaskArray taskList;

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public RecurCommand(int targetIndex, String args) {
        this.targetIndex = targetIndex;
        this.args = args;
        this.taskList = new TaskArray();
    }
    
    public RecurCommand(String args) {
        this(-1, args);
    }
    
    @Override
    public CommandResult execute() {
        assert model != null;
        ReadOnlyTask task;
        
        try {
            task = getTaskFromIndexOrLastModified(targetIndex);
            DateGroup dg = new PrettyTimeParser().parseSyntax(args).get(0);
            addRecurTasks(task, dg, taskList);
            model.addTask(taskList.getArray());
            CommandHistory.addExecutedCommand(this);
            return new CommandResult(String.format(MESSAGE_SUCCESS, taskList.toString()));
            
        } catch (UniqueTaskList.DuplicateTaskException dte) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (IndexOutOfBoundsException ioobe) {
            return new CommandResult(MESSAGE_FAILURE);
        } catch (NullPointerException npe) {
            return new CommandResult(MESSAGE_INVALID_TASK_FOR_RECUR);
        } catch (TaskNotFoundException tnfe) {
            return new CommandResult(tnfe.getMessage());
        }
    }


    @Override
    public CommandResult revert() {
        assert model != null;
        try {
            model.deleteTask(taskList.getArray());
            CommandHistory.addRevertedCommand(this);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }
        return new CommandResult(String.format(MESSAGE_REVERT_COMMAND, COMMAND_WORD, taskList.toString()));
    }
    
    private void addRecurTasks(ReadOnlyTask task, DateGroup dg, TaskArray taskList) {
        Task toAdd;
        do {
            toAdd = new Task(task);
            toAdd.addDuration(dg.getRecurInterval());
            taskList.add(toAdd);
            task = toAdd;
        } while ((toAdd.getEndDate().getDate().getTime() + dg.getRecurInterval()) 
                < dg.getRecursUntil().getTime());
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\ReplaceCommand.java
``` java

/**
 * Replaces a task in the task scheduler.
 */
public class ReplaceCommand extends Command {

    public static final String COMMAND_WORD = "replace";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Replaces a task in the scheduler. "
            + "Parameters: INDEX TASK from START_DATE to END_DATE at LOCATION \n"
            + "Example: " + COMMAND_WORD
            + " 1 Must Do CS2103 Pretut\n"
            + "Example: " + COMMAND_WORD
            + " 2 new task name from 10-Oct-2016 8am to 10-Oct-2016 9am at NUS\n"
            + "Example: " + COMMAND_WORD
            + " 1 another new task name from 11-Oct-2016 8am to 11-Oct-2016 9am at there\n";

    public static final String MESSAGE_SUCCESS = "Task replaced: %1$s";
    
    public final int targetIndex;
    private final Task newTask;
    private Task oldTask;

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public ReplaceCommand(int targetIndex, Task toReplace) {

        this.targetIndex = targetIndex;
        this.newTask = toReplace;
    }

    @Override
    public CommandResult execute() {
        try {
            oldTask = new Task(getTaskFromIndexOrLastModified(targetIndex));
            model.replaceTask(oldTask, newTask);
            CommandHistory.addExecutedCommand(this);
            CommandHistory.setModTask(newTask);
        } catch (DuplicateTaskException dpe) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (IndexOutOfBoundsException iobe) { 
            return new CommandResult(iobe.getMessage());
        } catch (TaskNotFoundException tnfe) {
            return new CommandResult(tnfe.getMessage());
        }
        return new CommandResult(String.format(MESSAGE_SUCCESS, oldTask));
    }

    @Override
    public CommandResult revert() {
        try {
            model.replaceTask(newTask, oldTask);
            CommandHistory.addRevertedCommand(this);
            CommandHistory.setModTask(oldTask);
        } catch (DuplicateTaskException e) {
            assert false : Messages.MESSAGE_TASK_CANNOT_BE_DUPLICATED;
        } catch (TaskNotFoundException e) {
            assert false : Messages.MESSAGE_TASK_CANNOT_BE_MISSING;
        }
        return new CommandResult(String.format(MESSAGE_REVERT_COMMAND, COMMAND_WORD, "\n" + newTask));
    }
}
```
###### \java\seedu\taskscheduler\logic\commands\SelectCommand.java
``` java
    @Override
    public CommandResult revert() {
        // This command not available for revert
        assert false : Messages.MESSAGE_PROGRAM_ERROR;
        return null;
    }

}
```
###### \java\seedu\taskscheduler\logic\parser\AddCommandParser.java
``` java

/**
 * Parses add command user input.
 */
public class AddCommandParser extends CommandParser {

    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    public Command prepareCommand(String args) {

        try {
            Task task = generateTaskFromArgs(args);
            if (task == null) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));      
            } else {
                return new AddCommand(task);
            }
        } catch (InputMismatchException ime) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE)); 
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
}
```
###### \java\seedu\taskscheduler\logic\parser\ClearCommandParser.java
``` java

/**
* Parses clear command user input.
*/
public class ClearCommandParser extends CommandParser{

    @Override
    public Command prepareCommand(String args) {
        return new ClearCommand();
    }
}
```
###### \java\seedu\taskscheduler\logic\parser\CommandParser.java
``` java

/**
 * Represents a command parser with hidden internal logic and the ability to be executed.
 */
public abstract class CommandParser {

    protected static final String START_DATE_DELIMITER = "s/";
    protected static final String END_DATE_DELIMITER = "e/";
    
    protected static final Pattern INDEX_COMMAND_FORMAT = Pattern.compile("(?<index>\\d+)(?<arguments>.*)");

    protected static final Pattern TASK_INDEX_ARGS_FORMAT = Pattern.compile("(?<targetIndex>.+)");

    protected static final Pattern KEYWORDS_ARGS_FORMAT =
            Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)"); // one or more keywords separated by whitespace
   
    protected static final Pattern EVENT_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(?<name>.+)"
                    + "(?>\\s+\\bfrom\\b)"
                    + "(?<startDate>.*)"
                    + "(?>\\s+\\bto\\b)"
                    + "(?<endDate>.*)"
                    + "(?>\\s+\\bat\\b)"
                    + "(?<address>.*)"
                    );  
//    protected static final Pattern EVENT_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
//            Pattern.compile("(?<name>[^/]+)"
//                    + " "
//                    + START_DATE_DELIMITER
//                    + "(?<startDate>[^/]*)"
//                    + " "
//                    + END_DATE_DELIMITER
//                    + "(?<endDate>.*)"
//                    + "(?>\\s+\\bat\\b)"
//                    + "(?<address>.*)"
//                    ); 
// 
    protected static final Pattern DEADLINE_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(?<name>.+?)"
                    + "(?>(\\s+\\b(by|on)\\b))"
                    + "(?<endDate>.*)"
                    );
    
    protected static final Pattern FLOATING_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(?<name>[\\p{Alnum} ]+)");

    protected static final Pattern SETPATH_DATA_ARGS_FORMAT =
            Pattern.compile("(?<name>[\\p{Alnum}|/|:|\\s+]+)"); 
    
    /**
     * Returns the specified index in the {@code command} IF a positive unsigned integer is given as the index.
     *   Returns an {@code Optional.empty()} otherwise.
     */
    protected Optional<Integer> parseIndex(String command) {
        final Matcher matcher = TASK_INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if(!StringUtil.isUnsignedInteger(index)){
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }

    public abstract Command prepareCommand(String args);
    
    /**
     * @param args that represents a task string
     * @return generated Task
     * @throws IllegalValueException if Task parameters are incorrect
     * @throws InputMismatchException if incorrect format
     */
    protected Task generateTaskFromArgs(String args) throws IllegalValueException, InputMismatchException{
        Matcher taskMatcher;
        
        taskMatcher = EVENT_DATA_ARGS_FORMAT.matcher(args);
        if (taskMatcher.matches()) {
            return new EventTask(new Name(taskMatcher.group("name")), new TaskDateTime(taskMatcher.group("startDate")),
                    new TaskDateTime(taskMatcher.group("endDate")), new Location(taskMatcher.group("address")));
        } else if (containsDelimiters(args)) {
            throw new InputMismatchException();
        }
        
        
        taskMatcher = DEADLINE_DATA_ARGS_FORMAT.matcher(args);
        if (taskMatcher.matches()) {
            return new DeadlineTask(new Name(taskMatcher.group("name")),
                    new TaskDateTime(taskMatcher.group("endDate")));
        }
        
        taskMatcher = FLOATING_DATA_ARGS_FORMAT.matcher(args);
        if (taskMatcher.matches()) {
            return new FloatingTask(new Name(taskMatcher.group("name")));
        }
        return null;
    }
    
    private boolean containsDelimiters(String args) {
        return (args.contains(START_DATE_DELIMITER) 
                || args.contains(END_DATE_DELIMITER));
    }
}
```
###### \java\seedu\taskscheduler\logic\parser\DeleteCommandParser.java
``` java

/**
* Parses delete command user input.
*/
public class DeleteCommandParser extends CommandParser {


    /**
     * Parses arguments in the context of the delete task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    public Command prepareCommand(String args) {

        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        return new DeleteCommand(index.get());
    }
}
```
###### \java\seedu\taskscheduler\logic\parser\EditCommandParser.java
``` java

/**
* Parses edit command user input.
*/
public class EditCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        
        final Matcher indexMatcher = INDEX_COMMAND_FORMAT.matcher(args);

        if (!indexMatcher.matches()) {
            return new EditCommand(-1,args);
        } else {
            int index = Integer.parseInt(indexMatcher.group("index"));
            assert index >= 0;
            String newArgs = indexMatcher.group("arguments").trim();
            return new EditCommand(index, newArgs);
        }
    }
}
```
###### \java\seedu\taskscheduler\logic\parser\ExitCommandParser.java
``` java

/**
* Parses exit command user input.
*/
public class ExitCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        return new ExitCommand();
    }
    

}
```
###### \java\seedu\taskscheduler\logic\parser\FindCommandParser.java
``` java

/**
* Parses find command user input.
*/
public class FindCommandParser extends CommandParser {

    /**
     * Parses arguments in the context of the find task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    public Command prepareCommand(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }

}
```
###### \java\seedu\taskscheduler\logic\parser\HelpCommandParser.java
``` java

/**
* Parses help command user input.
*/
public class HelpCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        return new HelpCommand();
    }

    
}
```
###### \java\seedu\taskscheduler\logic\parser\ListCommandParser.java
``` java

/**
* Parses list command user input.
*/
public class ListCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        return new ListCommand();
    }

    
}
```
###### \java\seedu\taskscheduler\logic\parser\MarkCommandParser.java
``` java

/**
* Parses mark command user input.
*/
public class MarkCommandParser extends CommandParser {

    /**
     * Parses arguments in the context of the mark task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    public Command prepareCommand(String args) {

        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkCommand.MESSAGE_USAGE));
        }

        return new MarkCommand(index.get());
    }

}
```
###### \java\seedu\taskscheduler\logic\parser\Parser.java
``` java
    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");

        try {
            String className = "seedu.taskscheduler.logic.parser."
                    +   commandWord.substring(0,1).toUpperCase() 
                    +   commandWord.substring(1)
                    +   "CommandParser";
                    
            CommandParser commandParser = (CommandParser)Class.forName(className).newInstance();
            return commandParser.prepareCommand(arguments.trim());
            
        } catch (Exception e) {
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        } 

    }
```
###### \java\seedu\taskscheduler\logic\parser\RecurCommandParser.java
``` java

/**
* Parses recur command user input.
*/
public class RecurCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        
        if (args.isEmpty()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                    RecurCommand.MESSAGE_USAGE));
        }
        Matcher matcher = INDEX_COMMAND_FORMAT.matcher(args);
        if(matcher.matches()){
            return new RecurCommand(Integer.parseInt(matcher.group("index")),
                    matcher.group("arguments"));
        } else {
            return new RecurCommand(args);
        }
    }
}
```
###### \java\seedu\taskscheduler\logic\parser\ReplaceCommandParser.java
``` java

/**
* Parses replace command user input.
*/
public class ReplaceCommandParser extends CommandParser{
    
    /**
     * Parses arguments in the context of the replace task command.
     *
     * @param matcherArgs full command args string
     * @return the prepared command
     */

    public Command prepareCommand(String args) {

        // Validate arg string format
        final Matcher indexMatcher = INDEX_COMMAND_FORMAT.matcher(args);

        if (!indexMatcher.matches()) {
            return generateReplaceCommand(args, -1);
        } else {
            int index = Integer.parseInt(indexMatcher.group("index"));
            assert index >= 0;
            String newArgs = indexMatcher.group("arguments").trim();
            return generateReplaceCommand(newArgs, index);
        }
    }

    private Command generateReplaceCommand(String args, int index) {
        try {
            Task task = generateTaskFromArgs(args);
            if (task == null) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ReplaceCommand.MESSAGE_USAGE));      
            } else {
                return new ReplaceCommand(index, task);
            }
        } catch (InputMismatchException ime) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ReplaceCommand.MESSAGE_USAGE)); 
        } catch (IllegalValueException ex) {
            return new IncorrectCommand(ex.getMessage());
        }
    }
}

```
###### \java\seedu\taskscheduler\logic\parser\SelectCommandParser.java
``` java

/**
* Parses select command user input.
*/
public class SelectCommandParser extends CommandParser {

    /**
     * Parses arguments in the context of the select task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    public Command prepareCommand(String args) {
        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
        }

        return new SelectCommand(index.get());
    }
}
```
###### \java\seedu\taskscheduler\model\Model.java
``` java
    /** Deletes the given task. */
    void deleteTask(ReadOnlyTask... targets) throws UniqueTaskList.TaskNotFoundException;

```
###### \java\seedu\taskscheduler\model\Model.java
``` java
    /** Marks the given task. 
     * @throws IllegalValueException */
    void markTask(Task target) throws UniqueTaskList.TaskNotFoundException, IllegalValueException;

```
###### \java\seedu\taskscheduler\model\Model.java
``` java
    /** Unmarks the given task. */
    void unMarkTask(Task target) throws UniqueTaskList.TaskNotFoundException, IllegalValueException;

```
###### \java\seedu\taskscheduler\model\Model.java
``` java
    /** Adds the given task */
    void addTask(Task... tasks) throws UniqueTaskList.DuplicateTaskException;
    
```
###### \java\seedu\taskscheduler\model\Model.java
``` java
    /** Replaces the given task. 
     * @throws DuplicateTaskException */
    void replaceTask(Task oldTask, Task newTask) throws TaskNotFoundException, DuplicateTaskException;
```
###### \java\seedu\taskscheduler\model\ModelManager.java
``` java
    @Override
    public synchronized void deleteTask(ReadOnlyTask... target) throws TaskNotFoundException {
        for (ReadOnlyTask task : target) {
            taskScheduler.removeTask(task);
        }
        indicateTaskSchedulerChanged();
    }

    @Override
    public synchronized void addTask(Task... tasks) throws UniqueTaskList.DuplicateTaskException {
        for (Task task : tasks) {
            taskScheduler.addTask(task);
        }
        updateFilteredListToShowAll();
        indicateTaskSchedulerChanged();
    }

    @Override
    public void replaceTask(Task oldTask, Task newTask) 
            throws TaskNotFoundException, UniqueTaskList.DuplicateTaskException {
        taskScheduler.replaceTask(oldTask, newTask);
        updateFilteredListToShowAll();
        indicateTaskSchedulerChanged();
        
    }   

    @Override
    public void markTask(Task task) 
            throws IllegalValueException, TaskNotFoundException {
        taskScheduler.markTask(task);
        updateFilteredListToShowAll();
        indicateTaskSchedulerChanged();
    }

    @Override
    public void unMarkTask(Task task) 
            throws IllegalValueException, TaskNotFoundException {
        taskScheduler.unMarkTask(task);
        updateFilteredListToShowAll();
        indicateTaskSchedulerChanged();
    }
    
```
###### \java\seedu\taskscheduler\model\task\DeadlineTask.java
``` java
/**
 * Represents a Deadline Task in the task scheduler.
 */
public class DeadlineTask extends Task {

    public DeadlineTask(Name name, TaskDateTime endDateTime) throws IllegalValueException {
        super(
            name, 
            new TaskDateTime(), 
            endDateTime, 
            new Location(), 
            TaskType.DEADLINE,
            new UniqueTagList());
    }

    public DeadlineTask(ReadOnlyTask source) {
        super(source);
    }

    public Task copy() {
        return new DeadlineTask(this);
    }
}
```
###### \java\seedu\taskscheduler\model\task\EventTask.java
``` java
/**
 * Represents an Event Task in the task scheduler.
 */
public class EventTask extends Task{

    public EventTask(Name name, TaskDateTime startDateTime, TaskDateTime endDateTime, Location address) throws IllegalValueException {
        super(name, startDateTime, endDateTime, address, 
                TaskType.EVENT, new UniqueTagList());
    }
    
    public EventTask(ReadOnlyTask source) {
        super(source);
    }

    @Override
    public Task copy() {
        return new EventTask(this);
    }
}
```
###### \java\seedu\taskscheduler\model\task\FloatingTask.java
``` java
/**
 * Represents a Floating Task in the task scheduler.
 */
public class FloatingTask extends Task {

    public FloatingTask(Name name) {
        super(name, new TaskDateTime(), new TaskDateTime(), new Location(),
                TaskType.FLOATING, new UniqueTagList());
    }

    public FloatingTask(ReadOnlyTask source) {
        super(source);
    }

    @Override
    public Task copy() {
        return new FloatingTask(this);
    }
}
```
###### \java\seedu\taskscheduler\model\task\Task.java
``` java
/**
 * Represents a Task in the task scheduler.
 * Guarantees: details are present and not null, field values are validated.
 */
public class Task implements ReadOnlyTask {

    private Name name;
    private TaskDateTime startDateTime;
    private TaskDateTime endDateTime;
    private Location address;
    private boolean completeStatus;
    private TaskType type;
    
    private UniqueTagList tags;

    /**
     * Every field must be present and not null.
     */
    public Task(Name name, TaskDateTime startDateTime, TaskDateTime endDateTime, Location address, TaskType type, UniqueTagList tags) {
        this(name, new TaskDateTime(startDateTime), new TaskDateTime(endDateTime), address, type, false, tags);
    }
    
    public Task(Name name, TaskDateTime startDateTime, TaskDateTime endDateTime, Location address, TaskType type, Boolean status, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(name, startDateTime, endDateTime, address, type, status, tags);
        this.name = name;
        this.startDateTime = new TaskDateTime(startDateTime);
        this.endDateTime = new TaskDateTime(endDateTime);
        this.address = address;
        this.tags = tags;
        this.type = type;
        this.completeStatus = status;
    }

    /**
     * Copy constructor.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getStartDate(), source.getEndDate(), source.getLocation(), source.getType(), source.getTags());
        this.completeStatus = source.getCompleteStatus();
    }

    @Override
    public Name getName() {
        return name;
    }

    @Override
    public TaskDateTime getStartDate() {
        return startDateTime;
    }

    @Override
    public TaskDateTime getEndDate() {
        return endDateTime;
    }

    @Override
    public Location getLocation() {
        return address;
    }
    
    @Override
    public boolean getCompleteStatus() {
        return completeStatus;
    }
    
    public void setName(Name name) {
        this.name = name;
    }
    
    public void setStartDate(TaskDateTime startDate) {
        this.startDateTime = startDate;
    }
    
    public void setEndDate(TaskDateTime endDate) {
        this.endDateTime = endDate;
    }

    public void setLocation(Location address) {
        this.address = address;
    }
    
    public void addDuration(long duration) {
        if (startDateTime.getDate() != null)
            this.startDateTime.setDate(startDateTime.getDate().getTime() + duration + 1);
        if (endDateTime.getDate() != null)
            this.endDateTime.setDate(endDateTime.getDate().getTime() + duration + 1);
    }
    
    /**
     * Add completed tag to indicate task done.
     * @throws IllegalValueException 
     */
    public void markComplete() throws IllegalValueException {
        if (completeStatus) {
            throw new IllegalValueException("");
        } else {
            completeStatus = true;
        }
        
//        try {
//            this.tags.add(new Tag("Completed"));
//        } catch (DuplicateTagException dte) { 
//            throw dte;
//        } catch (IllegalValueException ive) {
//            assert false : "The tag cannot be illegal value";
//        } 
    }

    /**
     * Add completed tag to indicate task done.
     * @throws IllegalValueException 
     */
    public void unMarkComplete() throws IllegalValueException {
        if (!completeStatus) {
            throw new IllegalValueException("");
        } else {
            completeStatus = false;
        }
//        try {
//            this.tags.remove(new Tag("Completed"));
//        }
//        catch (NullPointerException npe) { 
//            throw npe;
//        } catch (IllegalValueException ive) {
//            assert false : "The tag cannot be illegal value";
//        }
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }

    /**
     * Replaces this task's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, startDateTime, endDateTime, address);
    }

    @Override
    public String toString() {
        return getAsText();
    }

```
###### \java\seedu\taskscheduler\model\task\Task.java
``` java
    @Override
    public Task copy() {
        return new Task(this);
    }

    @Override
    public TaskType getType() {
        return type;
    }
    
    public void setType(TaskType type) {
        this.type = type;
    }

}
```
###### \java\seedu\taskscheduler\model\task\TaskArray.java
``` java

/**
 * Represents the Task array model.
 */

public class TaskArray {

    private final ArrayList<Task> taskList;
    
    public TaskArray() {
        taskList = new ArrayList<Task>();
    }
    
    public void add(Task task) {
        taskList.add(task);
    }

    public Task[] getArray() {
        return taskList.toArray(new Task[taskList.size()]);
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (Task task : taskList) {
            sb.append("\n");
            sb.append(task.toString());
        }
        return sb.toString();
    }
    
}
```
###### \java\seedu\taskscheduler\model\task\TaskDateTime.java
``` java

/**
* Represents the Task date and time model.
*/
public class TaskDateTime {

    private Date date;
    private boolean enShowTime = false;
    
    public TaskDateTime() {
        date = null;
    }
    
    public TaskDateTime(TaskDateTime source) {
        this.date = source.getDate();
        this.enShowTime = source.enShowTime;
    }
    
    public TaskDateTime(String args) throws IllegalValueException {
        if (args == null || args.trim().isEmpty())
            return;
        
        date = DateFormatter.convertStringToDate(args);
        checkIfTimeIsSpecified(new Date());
    }

    public void setDate(long l) { 
        Date newDate = new Date(l);
        checkIfTimeIsSpecified(newDate);
        this.date = newDate; 
    }

    private void checkIfTimeIsSpecified(Date other) {
        if (!DateFormatter.convertDateToFullTimeString(date)
                .equals(DateFormatter.convertDateToFullTimeString(other))) {
            enShowTime = true;
        }
    }
    
    public Date getDate() { 
        return date;
    }
    
    public String getDisplayDateString() {
        if (date == null)
            return "";
        else 
            return DateFormatter.convertDateToDisplayString(date);
    }
    
    public String getDisplayTimeString() {
        if (enShowTime)
            return " " + DateFormatter.convertTimeToDisplayString(date);
        else
            return "";
    }
    
    public boolean getEnShowTime() {
        return enShowTime;
    }
    
    public String getDisplayString() {
        return getDisplayDateString() + getDisplayTimeString();
    }
    
    public String toString() {
        return getDisplayString();
    }
    
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskDateTime // instanceof handles nulls
                && isSameStateAs((TaskDateTime) other));
    }
    
    public boolean isSameStateAs(TaskDateTime other) {
        return getDisplayString().equals(other.getDisplayString());
    }
}
```
###### \java\seedu\taskscheduler\model\task\UniqueTaskList.java
``` java
    /**
     * Adds a task to the list.
     *
     * @throws DuplicateTaskException if the task to add is a duplicate of an existing task in the list.
     */
    public void add(Task toAdd) throws DuplicateTaskException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateTaskException();
        }
        int index = indexToInsertInSortedOrder(toAdd);
        internalList.add(index, toAdd);
        EventsCenter.getInstance().post(new JumpToListRequestEvent(index));
    }
    
```
###### \java\seedu\taskscheduler\model\task\UniqueTaskList.java
``` java
    /**
     * Determines the sorted position of the toAdd in the list
     * @param toAdd
     * @return
     */
    private int indexToInsertInSortedOrder(Task toAdd) {
        if (toAdd.getType() == TaskType.EVENT) {
            for (int i = 0; i < internalList.size(); i++) {
                Task task = internalList.get(i);
                if (task.getType() == TaskType.FLOATING) {
                    return i;
                } else if (task.getType() == TaskType.DEADLINE) {
                    if (task.getEndDate().getDate().after(toAdd.getStartDate().getDate())) {
                        return i;
                    }
                } else {
                    if (task.getStartDate().getDate().after(toAdd.getStartDate().getDate())) {
                        return i;
                    }
                }
            }
        } else if (toAdd.getType() == TaskType.DEADLINE) {
            for (int i = 0; i < internalList.size(); i++) {
                Task task = internalList.get(i);
                if (task.getType() == TaskType.FLOATING) {
                    return i;
                } else if (task.getType() == TaskType.DEADLINE) {
                    if (task.getEndDate().getDate().after(toAdd.getEndDate().getDate())) {
                        return i;
                    }
                } else {
                    if (task.getStartDate().getDate().after(toAdd.getEndDate().getDate())) {
                        return i;
                    }
                }
            }
        }
        return internalList.size();
    }

```
###### \java\seedu\taskscheduler\model\task\UniqueTaskList.java
``` java
    /**
     * Replaces a task in the list.
     *
     * @throws DuplicateTaskException if the task to replace is a duplicate of an existing task in the list.
     */
    public void replace(Task oldTask, Task newTask) throws DuplicateTaskException, TaskNotFoundException{
        assert oldTask != null;
        if (contains(newTask)) {
            throw new DuplicateTaskException();
        }
        int index = internalList.indexOf(oldTask);
        if (index < 0) {
            throw new TaskNotFoundException();
        }
        internalList.remove(index);
        index = indexToInsertInSortedOrder(newTask);
        internalList.add(index, newTask);
        EventsCenter.getInstance().post(new JumpToListRequestEvent(index));
    }

```
###### \java\seedu\taskscheduler\model\task\UniqueTaskList.java
``` java
    /**
     * Marks a task to the list as completed.
     *
     * @throws TaskNotFoundException
     * @throws IllegalValueException if the task is already complete.
     */
    public void mark(Task toMark) throws TaskNotFoundException, IllegalValueException{
        assert toMark != null;
        int index = internalList.indexOf(toMark);
        if (index < 0) {
            throw new TaskNotFoundException();
        }
        toMark.markComplete();
        internalList.set(index, toMark);
        EventsCenter.getInstance().post(new JumpToListRequestEvent(index));
    }
    

```
###### \java\seedu\taskscheduler\model\task\UniqueTaskList.java
``` java
    /**
     * Unmarks a task to the list as completed.
     *
     * @throws TaskNotFoundException
     * @throws DuplicateTagException if the task is already complete.
     */
    public void unMark(Task toMark) throws TaskNotFoundException, IllegalValueException {
        assert toMark != null;
        int index = internalList.indexOf(toMark);
        if (index < 0) {
            throw new TaskNotFoundException();
        }
        toMark.unMarkComplete();
        internalList.set(index, toMark);
        EventsCenter.getInstance().post(new JumpToListRequestEvent(index));
    }
    
```
###### \java\seedu\taskscheduler\model\TaskScheduler.java
``` java
    /**
     * Replaces a task in the task scheduler
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void replaceTask(Task oldTask, Task newTask) 
            throws UniqueTaskList.DuplicateTaskException, UniqueTaskList.TaskNotFoundException {
        tasks.replace(oldTask, newTask);        
        syncTagsWithMasterList(newTask);
    }

```
###### \java\seedu\taskscheduler\model\TaskScheduler.java
``` java
    /**
     * Marks a task in the task scheduler as completed
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     * @throws DuplicateTagException 
     */
    public void markTask(Task task) 
            throws UniqueTaskList.TaskNotFoundException, IllegalValueException {
        tasks.mark(task);
    }

```
###### \java\seedu\taskscheduler\model\TaskScheduler.java
``` java
    /**
     * Unmarks a task in the task scheduler as completed
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     * @throws DuplicateTagException 
     */
    public void unMarkTask(Task task) 
            throws UniqueTaskList.TaskNotFoundException, IllegalValueException {
        tasks.unMark(task);
    }
    
```
###### \java\seedu\taskscheduler\ui\MainWindow.java
``` java
    public void fillInnerParts() {
        taskListPanel = TaskListPanel.load(primaryStage, getTaskListPlaceholder(), logic.getFilteredTaskList());
        priorityListPanel = PriorityListPanel.load(primaryStage, getPriorityListPlaceholder(), 
                logic.getPriorityFilteredTaskList());
        resultDisplay = ResultDisplay.load(primaryStage, getResultDisplayPlaceholder());
        statusBarFooter = StatusBarFooter.load(primaryStage, getStatusbarPlaceholder(), config.getTaskSchedulerFilePath());
        commandBox = CommandBox.load(primaryStage, getCommandBoxPlaceholder(), resultDisplay, logic);
    }
```
###### \java\seedu\taskscheduler\ui\PriorityListPanel.java
``` java

/**
 * Panel containing the list of tasks.
 */
public class PriorityListPanel extends UiPart {
    private final Logger logger = LogsCenter.getLogger(PriorityListPanel.class);
    private static final String FXML = "PriorityListPanel.fxml";
    private VBox panel;
    private AnchorPane placeHolderPane;

    @FXML
    private ListView<ReadOnlyTask> priorityListView;

    public PriorityListPanel() {
        super();
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static PriorityListPanel load(Stage primaryStage, AnchorPane priorityListPlaceholder,
                                       ObservableList<ReadOnlyTask> taskList) {
        PriorityListPanel priorityListPanel =
                UiPartLoader.loadUiPart(primaryStage, priorityListPlaceholder, new PriorityListPanel());
        priorityListPanel.configure(taskList);
        return priorityListPanel;
    }

    private void configure(ObservableList<ReadOnlyTask> taskList) {
        setConnections(taskList);
        addToPlaceholder();
    }

    private void setConnections(ObservableList<ReadOnlyTask> taskList) {
        priorityListView.setItems(taskList);
        priorityListView.setCellFactory(listView -> new TaskListViewCell());
        setEventHandlerForSelectionChangeEvent();
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    private void setEventHandlerForSelectionChangeEvent() {
        priorityListView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                logger.fine("Selection in person list panel changed to : '" + newValue + "'");
                raise(new TaskPanelSelectionChangedEvent(newValue));
            }
        });
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            priorityListView.scrollTo(index);
            priorityListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class TaskListViewCell extends ListCell<ReadOnlyTask> {

        public TaskListViewCell() {
        }

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(TaskCard.load(task, getIndex() + 1).getLayout());
            }
        }
    }

}
```
###### \java\seedu\taskscheduler\ui\TaskCard.java
``` java
    public void hideFieldsAccordingToType(ReadOnlyTask task) {
        if (task.getType() == TaskType.DEADLINE) {
            phone.setVisible(false);
            address.setVisible(false);
        } else if (task.getType() == TaskType.FLOATING) {
            phone.setVisible(false);
            address.setVisible(false);
            email.setVisible(false);
        }
    }

```
###### \java\seedu\taskscheduler\ui\TaskCard.java
``` java
    public void indicatingColourByCondition(ReadOnlyTask task) {
        
        if (task.getCompleteStatus()) {
            completeStatus.setFill(COMPLETED_INDICATION);
        } else if (task.getEndDate().getDate() != null && task.getEndDate().getDate().before(new Date())) {
            completeStatus.setFill(OVERDUE_INDICATION);
        }
        
    }
}
```
###### \resources\view\PriorityListPanel.fxml
``` fxml

<VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.taskscheduler.ui.PriorityListPanel" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
    <children>
        <ListView fx:id="priorityListView" VBox.vgrow="ALWAYS" />
    </children>
</VBox>
```
